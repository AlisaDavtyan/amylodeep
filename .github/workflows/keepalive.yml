name: AmyloDeep Keep-Alive

on:
  schedule:
    - cron: "0 */6 * * *"
  workflow_dispatch:

jobs:
  interact:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
    - name: Setup Node
      uses: actions/setup-node@v4
      with:
        node-version: "20"

    - name: Install Playwright
      run: |
        npm init -y
        npm i playwright
        npx playwright install --with-deps chromium

    - name: Interact with AmyloDeep App
      run: |
        node - <<'JS'
        const {chromium} = require('playwright');

        async function sleep(ms) {
          return new Promise(resolve => setTimeout(resolve, ms));
        }

        (async () => {
          const browser = await chromium.launch({headless: true});
          const context = await browser.newContext({
            userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
          });
          const page = await context.newPage();
          
          try {
            console.log("ðŸŒ Loading AmyloDeep app...");
            await page.goto("https://amylodeep.streamlit.app/", {
              waitUntil: "networkidle",
              timeout: 120000
            });
            
            console.log("âœ… Page loaded successfully");

            // Check if app is sleeping
            try {
              const wakeButton = await page.waitForSelector('text="Yes, get this app back up!"', {timeout: 8000});
              if (wakeButton) {
                console.log("ðŸ˜´ App is sleeping, clicking wake-up button...");
                await wakeButton.click();
                console.log("â³ Waiting for app to wake up (45 seconds)...");
                await sleep(45000);
                console.log("âœ… Wake-up wait completed");
              }
            } catch (e) {
              console.log("âœ… App is not sleeping (no wake-up button found)");
            }

            // Wait for Streamlit to be ready (look for spinners to disappear)
            console.log("â³ Waiting for Streamlit to be ready...");
            await sleep(10000);

            // Look for your specific textarea with key="sequence_input"
            console.log("ðŸ” Looking for sequence input textarea...");
            
            let textarea = null;
            const selectors = [
              '[data-testid="stTextArea"] textarea',
              'textarea[aria-label*="sequence_input"]',
              'textarea',
              '[key="sequence_input"] textarea'
            ];

            for (const selector of selectors) {
              try {
                textarea = page.locator(selector).first();
                await textarea.waitFor({state: "visible", timeout: 15000});
                console.log(`âœ… Found textarea with selector: ${selector}`);
                break;
              } catch (e) {
                console.log(`âŒ Selector "${selector}" not found, trying next...`);
                textarea = null;
              }
            }

            if (!textarea) {
              throw new Error("Could not find sequence input textarea");
            }

            // Fill the textarea with a test sequence
            console.log("ðŸ“ Filling sequence input...");
            const testSequence = "ACDEFGHIKLMNPQRSTVWYACDEFGHIKLMNPQRSTVWY";
            await textarea.fill(testSequence);
            await sleep(2000);
            console.log(`âœ… Filled sequence: ${testSequence}`);

            // Optionally adjust the slider (your slider has key="window_slider")
            console.log("ðŸŽšï¸ Adjusting window size slider...");
            try {
              // Look for the slider input
              const slider = page.locator('input[type="range"]').first();
              await slider.waitFor({state: "visible", timeout: 10000});
              
              // Set value to 12 (within your range of 3-30)
              await slider.evaluate(el => {
                el.value = 12;
                el.dispatchEvent(new Event('input', { bubbles: true }));
                el.dispatchEvent(new Event('change', { bubbles: true }));
              });
              console.log("âœ… Set window size to 12");
              await sleep(1000);
            } catch (e) {
              console.log("âš ï¸ Could not find/adjust slider, using default");
            }

            // Find and click the Predict button (inside form)
            console.log("ðŸ” Looking for Predict button...");
            
            let predictButton = null;
            const buttonSelectors = [
              '[data-testid="stFormSubmitButton"] button',
              'button[kind="formSubmit"]',
              'button:has-text("Predict")',
              'form button'
            ];

            for (const selector of buttonSelectors) {
              try {
                predictButton = page.locator(selector);
                await predictButton.waitFor({state: "visible", timeout: 10000});
                const text = await predictButton.textContent();
                if (text && text.toLowerCase().includes('predict')) {
                  console.log(`âœ… Found Predict button: "${text.trim()}"`);
                  break;
                }
              } catch (e) {
                console.log(`âŒ Button selector "${selector}" failed`);
                predictButton = null;
              }
            }

            if (!predictButton) {
              throw new Error("Could not find Predict button");
            }

            // Click the predict button
            console.log("ðŸ–±ï¸ Clicking Predict button...");
            await predictButton.click();
            console.log("âœ… Predict button clicked");

            // Wait for prediction to complete
            console.log("â³ Waiting for prediction to complete...");
            
            try {
              // Wait for the "Position-wise Probabilities" heading to appear
              await page.waitForSelector('text="Position-wise Probabilities"', {timeout: 60000});
              console.log("âœ… Prediction completed - results are showing!");
            } catch (e) {
              console.log("âš ï¸ Results heading not found, but waiting a bit more...");
              await sleep(20000);
            }

            // Keep the connection alive to simulate user staying on page
            console.log("ðŸ”— Keeping connection alive for 30 seconds...");
            await sleep(30000);

            console.log("ðŸŽ‰ AmyloDeep interaction completed successfully!");

          } catch (error) {
            console.error("âŒ Error during interaction:", error.message);
            
            // Take screenshot for debugging
            try {
              const screenshot = await page.screenshot({ 
                path: 'debug-screenshot.png',
                fullPage: true 
              });
              console.log("ðŸ“¸ Screenshot saved for debugging");
            } catch (screenshotError) {
              console.log("ðŸ“¸ Could not take screenshot");
            }

            // Get current URL and page title for debugging
            try {
              const url = await page.url();
              const title = await page.title();
              console.log(`ðŸ” Current URL: ${url}`);
              console.log(`ðŸ” Page title: ${title}`);
              
              // If we at least reached the Streamlit app, consider it a partial success
              if (url.includes('amylodeep.streamlit.app')) {
                console.log("âœ… At least reached the AmyloDeep app");
              } else {
                throw error; // Re-throw if we didn't even reach the app
              }
            } catch (debugError) {
              console.log("Could not get debug info");
              throw error;
            }
            
          } finally {
            await browser.close();
            console.log("ðŸ”š Browser closed");
          }
        })().catch(err => {
          console.error("ðŸ’¥ Fatal error:", err);
          process.exit(1);
        });
        JS